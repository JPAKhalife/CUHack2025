{"version":3,"sources":["../effects.ts"],"sourceRoot":"","sourcesContent":["import type { GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport { validateBelongsToLink } from \"../auth\";\nimport { getActionContextFromLocalStorage } from \"../effects\";\nimport { modelsMap } from \"../metadata\";\nimport type { AnyParams } from \"../types\";\n\n/**\n * Applicable for multi-tenant user authenticated apps.\n * Enforces that the given record is only accessible by the current logged in user.\n *\n * For new records: sets the the current session's `userId` to the record.\n * For existing records: Verifies the record objects `userId` matches the one from the current session.\n *\n * @param params - incoming data validated against the current `userId`\n * @param record - record used to validate or set the `userId` on\n * @param {Object} options - Additional options for cross-user validation\n * @param {string} options.userBelongsToField - Specifies which related model is used for cross-user validation.\n */\nexport async function preventCrossUserDataAccess(\n  params: AnyParams,\n  record: GadgetRecord<any>,\n  options?: { userBelongsToField?: string }\n): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross user data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\n      \"The `params` parameter is required in preventCrossUserDataAccess(params, record, options?: { userBelongsToField: string })\"\n    );\n  }\n  if (!record) {\n    throw new Error(\n      \"The `record` parameter is required in preventCrossUserDataAccess(params, record, options?: { userBelongsToField: string })\"\n    );\n  }\n  const model = context.model;\n\n  const userBelongsToField = options?.userBelongsToField;\n\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const userId: string | undefined = context.session?.get(\"user\");\n  const input = params[model.apiIdentifier];\n\n  const userModel = context.authConfig?.userModelKey\n    ? Object.values(modelsMap).find((model) => model.key === context.authConfig?.userModelKey)\n    : undefined;\n\n  if (userId && userModel) {\n    validateBelongsToLink({\n      input,\n      record,\n      params,\n      tenantId: userId,\n      model,\n      tenantModelKey: userModel.key,\n      tenantBelongsToField: userBelongsToField,\n      tenantType: \"user\",\n    });\n  }\n}\n"],"names":["preventCrossUserDataAccess","params","record","options","context","getActionContextFromLocalStorage","type","Error","model","userBelongsToField","userId","session","get","input","apiIdentifier","userModel","authConfig","userModelKey","Object","values","modelsMap","find","key","undefined","validateBelongsToLink","tenantId","tenantModelKey","tenantBelongsToField","tenantType"],"mappings":";;;;+BAkBsBA;;;eAAAA;;;sBAjBgB;yBACW;0BACvB;AAenB,eAAeA,2BACpBC,MAAiB,EACjBC,MAAyB,EACzBC,OAAyC;IAEzC,MAAMC,UAAUC,IAAAA,yCAAgC;IAEhD,IAAID,QAAQE,IAAI,IAAI,UAAU;QAC5B,MAAM,IAAIC,MAAM;IAClB;IACA,IAAI,CAACN,QAAQ;QACX,MAAM,IAAIM,MACR;IAEJ;IACA,IAAI,CAACL,QAAQ;QACX,MAAM,IAAIK,MACR;IAEJ;IACA,MAAMC,QAAQJ,QAAQI,KAAK;IAE3B,MAAMC,qBAAqBN,SAASM;IAEpC,6EAA6E;IAC7E,IAAI,CAACD,OAAO;QACV;IACF;IAEA,MAAME,SAA6BN,QAAQO,OAAO,EAAEC,IAAI;IACxD,MAAMC,QAAQZ,MAAM,CAACO,MAAMM,aAAa,CAAC;IAEzC,MAAMC,YAAYX,QAAQY,UAAU,EAAEC,eAClCC,OAAOC,MAAM,CAACC,mBAAS,EAAEC,IAAI,CAAC,CAACb,QAAUA,MAAMc,GAAG,KAAKlB,QAAQY,UAAU,EAAEC,gBAC3EM;IAEJ,IAAIb,UAAUK,WAAW;QACvBS,IAAAA,2BAAqB,EAAC;YACpBX;YACAX;YACAD;YACAwB,UAAUf;YACVF;YACAkB,gBAAgBX,UAAUO,GAAG;YAC7BK,sBAAsBlB;YACtBmB,YAAY;QACd;IACF;AACF"}