<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShapeSplosion</title>
    <link rel="icon" href="/public/favicon.png">
    <style>
      /* Background styles */
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #2c0954 0%, #1a3a6c 100%);
        min-height: 100vh;
        overflow-x: hidden;
        position: relative;
      }
      
      /* Background texture overlay */
      body::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("data:image/png;base64,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");
        opacity: 0.05;
        z-index: -2;
        pointer-events: none;
      }
      
      .shapes-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
      }
      
      .floating-shape {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.08);
        border-radius: 0;
        z-index: -1;
        animation: float-animation 15s infinite linear;
        opacity: 0.4;
      }
      
      .floating-shape.triangle {
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      }
      
      .floating-shape.square {
        border-radius: 0;
      }
      
      .floating-shape.pentagon {
        clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
      }
      
      .floating-shape.hexagon {
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
      }
      
      .floating-shape.circle {
        border-radius: 50%;
      }
      
      @keyframes float-animation {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        25% {
          transform: translate(10px, 10px) rotate(90deg);
        }
        50% {
          transform: translate(0, 20px) rotate(180deg);
        }
        75% {
          transform: translate(-10px, 10px) rotate(270deg);
        }
        100% {
          transform: translate(0, 0) rotate(360deg);
        }
      }
      
      /* Game canvas and container styles */
      canvas {
        width: 40% !important;
        margin-left: auto;
        margin-right: auto;
        display: block;
        position: relative;
        z-index: 1;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.98);
      }
      
      #game {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px 0;
        position: relative;
        z-index: 1;
      }
      
      /* Game instructions styles */
      #game-instructions {
        width: 80%;
        max-width: 800px;
        margin: 30px auto;
        background: linear-gradient(to bottom right, #f5f7fa, #e4e8ec);
        border-radius: 12px;
        padding: 20px 30px;
        box-shadow: 0 10px 20px rgba(0,0,0,0.35);
        font-family: 'Arial', sans-serif;
        color: #333;
        position: relative;
        z-index: 1;
      }
      
      #game-instructions h2 {
        text-align: center;
        color: #ff5252;
        font-size: 28px;
        margin-bottom: 20px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      }
      
      .instructions-content {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 20px;
      }
      
      .instruction-section {
        flex: 1;
        min-width: 220px;
        padding: 15px;
        background-color: rgba(255,255,255,0.7);
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      }
      
      .instruction-section h3 {
        color: #7b1fa2;
        font-size: 20px;
        margin-bottom: 12px;
        border-bottom: 2px solid rgba(123, 31, 162, 0.3);
        padding-bottom: 5px;
      }
      
      .instruction-section p {
        margin: 10px 0;
        line-height: 1.5;
      }
      
      @media (max-width: 768px) {
        #game-instructions {
          width: 90%;
          padding: 15px;
        }
        
        .instructions-content {
          flex-direction: column;
        }
      }

      /* Animated ellipsis styles */
      .loading-dots {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 24px;
      }
      
      .dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        margin: 0 3px;
        border-radius: 50%;
        background-color: #333;
        animation: dot-bounce 1.4s infinite ease-in-out;
      }
      
      .dot:nth-child(1) {
        animation-delay: 0s;
      }
      
      .dot:nth-child(2) {
        animation-delay: 0.2s;
      }
      
      .dot:nth-child(3) {
        animation-delay: 0.4s;
      }
      
      @keyframes dot-bounce {
        0%, 80%, 100% { 
          transform: translateY(0);
        }
        40% { 
          transform: translateY(-10px);
        }
      }
      
      .fancy-button {
        position: fixed;
        left: 20px;
        background: linear-gradient(45deg, #ff5252, #ff1744);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 12px 24px;
        font-family: 'Arial', sans-serif;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        transform: scale(0);
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        z-index: 1000;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
      }
      
      .fancy-button:hover {
        transform: scale(1.05) translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.3);
      }
      
      .fancy-button:active {
        transform: scale(0.95) translateY(1px);
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      }
      
      .fancy-button.show {
        animation: button-pop 0.5s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      
      #fancy-insult-button {
        top: 20px;
        background: linear-gradient(45deg, #ff5252, #ff1744);
      }
      
      #fancy-insult-button:hover {
        background: linear-gradient(45deg, #ff1744, #d50000);
      }
      
      #insult-me-button {
        top: 80px;
        background: linear-gradient(45deg, #4a148c, #7b1fa2);
      }
      
      #insult-me-button:hover {
        background: linear-gradient(45deg, #7b1fa2, #4a148c);
      }
      
      @keyframes button-pop {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        70% {
          transform: scale(1.1);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      #shapey-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        align-items: flex-end;
        transition: transform 2s ease-in-out;
        z-index: 1000;
        filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
      }
      
      #shapey-character {
        width: 100px;
        height: 100px;
        object-fit: contain;
        transition: transform 0.3s ease;
        animation: bobbing 2s ease-in-out infinite;
        image-rendering: -webkit-optimize-contrast; /* For webkit (Chrome, Safari) */
        image-rendering: crisp-edges; /* For Firefox */
        image-rendering: pixelated; /* For other browsers */
      }
      
      #shapey-character.offscreen {
        transform: translateX(120px);
        animation: none;
      }
      
      #shapey-character.sliding-in {
        animation: slide-in 1s forwards;
      }
      
      @keyframes slide-in {
        from { transform: translateX(120px); }
        to { transform: translateX(0); }
      }
      
      @keyframes bobbing {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
      }
      
      #shapey-character.rolling {
        animation: roll 2s linear forwards;
      }
      
      @keyframes roll {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      #speech-bubble {
        position: relative;
        background: #ffffff;
        border-radius: 20px;
        padding: 15px;
        margin-right: 10px;
        max-width: 350px;
        width: 20%;
        min-height: 50px;
        box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        transition: all 0.4s ease-out;
        transform-origin: bottom right;
        opacity: 1;
        z-index: 10;
      }
      
      #speech-bubble.hidden {
        transform: scale(0.1);
        opacity: 0;
        max-width: 50px;
        max-height: 50px;
      }
      
      #speech-bubble.animating {
        animation: bubble-pop 0.4s ease-out forwards;
        opacity: 0;
      }
      
      @keyframes bubble-pop {
        0% {
          transform: scale(0.1);
          opacity: 0;
        }
        25% {
          transform: scale(0.6);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      
      #speech-bubble:after {
        content: '';
        position: absolute;
        right: 0px;
        bottom: 45px;
        width: 0;
        height: 0;
        border: 10px solid transparent;
        border-left-color: #ffffff;
        border-right: 0;
        margin-top: -10px;
        margin-right: -10px;
      }
      
      #speech-text {
        font-family: Arial, sans-serif;
        font-size: 16px;
        min-height: 1em;
        white-space: pre-line;
        line-height: 1.4;
      }
      
      .hidden {
        display: none !important;
      }
      
      .paragraph-break {
        display: block;
        margin-top: 10px;
      }
      
      /* Pulse animation for click feedback */
      @keyframes pulse-feedback {
        0% { 
          transform: scale(1);
          opacity: 1; 
        }
        50% { 
          transform: scale(1.05); 
          opacity: 0.9;
        }
        100% { 
          transform: scale(1);
          opacity: 1; 
        }
      }
      
      .pulse {
        animation: pulse-feedback 0.3s ease-in-out;
      }
      
      /* Speech bubble jump animation */
      @keyframes bubble-jump {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-15px); }
      }
      
      #speech-bubble.jumping {
        animation: bubble-jump 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="shapes-background" id="shapes-background"></div>
    <button id="fancy-insult-button" class="fancy-button hidden">Insult Shapey</button>
    <button id="insult-me-button" class="fancy-button hidden">Insult Me</button>

    <div id="game-instructions">
        <h2>How to Play</h2>
        <div class="instructions-content">
          <div class="instruction-section">
            <h3>Controls</h3>
            <p>• Move your shape with mouse or touch</p>
            <p>• Click to drop your shape</p>
            <p>• Merge same shapes to create larger ones</p>
          </div>
          
          <div class="instruction-section">
            <h3>Shape Hierarchy</h3>
            <p>Triangles → Squares → Pentagons → Hexagons → Circles</p>
            <p>Larger shapes are worth more points!</p>
          </div>
          
          <div class="instruction-section">
            <h3>Game Over</h3>
            <p>The game ends when there's no more room to place shapes on the board.</p>
            <p>Try to create the largest shapes possible before running out of space!</p>
          </div>
        </div>
      </div>
    </div>
    
    <div id="game">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <script type="module">
        import { initializeGame } from '/web/Game/index.ts';
        
        // Initialize the game when the window loads
        window.addEventListener('load', () => {
          const canvas = document.getElementById('gameCanvas');
          if (canvas) {
            const game = initializeGame(canvas, {
              width: 800,
              height: 600,
              gravity: { x: 0, y: 0.2 },
              maxShapes: 20,
              spawnRate: 1000,
              difficulty: 'medium',
              soundEnabled: true,
              backgroundMusic: false,
              particleEffects: true
            });
            
            console.log('Game initialized successfully');
          } else {
            console.error('Game canvas not found');
          }
        });
      </script>
      <div id="insultText"></div>
      
      
    
    <div id="shapey-container">
      <div id="speech-bubble" class="hidden">
        <div id="speech-text"></div>
        <div id="loading-dots" class="loading-dots hidden">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
      </div>
      <img id="shapey-character" src="/public/ShapeyHappy.png" alt="Shapey" class="happy">
    </div>

    <script>
      // Calculate speech bubble size accurately by measuring the text dimensions
      function calculateTextDimensions(text) {
        // Create a hidden element to measure text dimensions
        const measurer = document.createElement('div');
        measurer.id = 'text-measure';
        measurer.style.position = 'absolute';
        measurer.style.visibility = 'hidden';
        measurer.style.maxWidth = '400px'; // Match the largest possible width
        measurer.style.fontFamily = 'Arial, sans-serif';
        measurer.style.fontSize = '16px';
        measurer.style.lineHeight = '1.4';
        measurer.style.whiteSpace = 'pre-line';
        measurer.style.padding = '15px'; // Match the padding of speech bubble
        measurer.innerHTML = formatText(text);
        
        // Add to DOM to measure
        document.body.appendChild(measurer);
        
        // Get dimensions
        const width = Math.min(400, measurer.scrollWidth + 30); // Add some padding
        const height = measurer.scrollHeight + 30; // Add some padding
        
        // Clean up
        document.body.removeChild(measurer);
        
        return { 
          width: width + 'px',
          height: height + 'px'
        };
      }
      
      // Format text with proper paragraph breaks
      function formatText(text) {
        // Replace double line breaks with special marker
        return text.replace(/\n\s*\n/g, '<span class="paragraph-break"></span>')
                   .replace(/\n/g, ' ');
      }
      
      // Variables to track the current typewriter state
      let currentTypewriterTimer = null;
      let currentTypewriterCallback = null;
      let currentTypewriterText = '';
      let currentTypewriterElement = null;
      let isTypewriterActive = false;
      let insultMeButtonShown = false; // Track if the insult me button has been shown
      let isInitialDialogue = false; // Track if current dialogue is the initial one
      let initialDialogueCompleted = false; // Track if initial dialogue has completed
      let shouldShowInsultButton = false; // Track if insult button should be shown
      let shouldShowInsultMeButton = false; // Track if insult me button should be shown

      // Function to skip the current typewriter animation
      function skipTypewriter() {
        // Only proceed if there's an active typewriter animation
        if (isTypewriterActive && currentTypewriterElement) {
          // Clear any existing timeouts
          if (currentTypewriterTimer) {
            clearTimeout(currentTypewriterTimer);
            currentTypewriterTimer = null;
          }
          
          // Complete the text immediately
          currentTypewriterElement.innerHTML = formatText(currentTypewriterText);
          
          // Reset the isTypewriterActive flag
          isTypewriterActive = false;
          
          // Show insult button if requested, including for initial dialogue
          if (shouldShowInsultButton || isInitialDialogue) {
            const insultButton = document.getElementById('fancy-insult-button');
            insultButton.classList.remove('hidden');
            insultButton.classList.add('show');
          }
          
          // Show insult me button only if explicitly requested, not for initial dialogue
          if (shouldShowInsultMeButton) {
            const insultMeButton = document.getElementById('insult-me-button');
            insultMeButton.classList.remove('hidden');
            insultMeButton.classList.add('show');
            insultMeButtonShown = true;
          }
          
          // Execute any pending callback after a short delay
          if (currentTypewriterCallback) {
            setTimeout(currentTypewriterCallback, 100);
            currentTypewriterCallback = null;
          }
          
          return true; // Animation was skipped
        }
        
        return false; // No animation was skipped
      }

      // Typewriter animation function
      function typeWriter(element, text, speed = 30, callback) {
        // Store the current typewriter state globally
        currentTypewriterElement = element;
        currentTypewriterText = text;
        currentTypewriterCallback = callback;
        isTypewriterActive = true;
        
        // Clear any existing typewriter animations
        if (currentTypewriterTimer) {
          clearTimeout(currentTypewriterTimer);
          currentTypewriterTimer = null;
        }

        let formattedText = formatText(text);
        let i = 0;
        let htmlMode = false;
        let htmlBuffer = '';
        
        // Clear the element completely before starting
        element.innerHTML = '';
        
        function type() {
          if (i < formattedText.length) {
            let char = formattedText.charAt(i);
            
            // Handle HTML tags for paragraph breaks
            if (char === '<') {
              htmlMode = true;
              htmlBuffer = '<';
            } else if (htmlMode) {
              htmlBuffer += char;
              if (char === '>') {
                element.innerHTML += htmlBuffer;
                htmlMode = false;
                htmlBuffer = '';
              }
            } else {
              element.innerHTML += char;
            }
            
            i++;
            currentTypewriterTimer = setTimeout(type, speed);
          } else {
            currentTypewriterTimer = null;
            isTypewriterActive = false;
            
            if (callback) {
              currentTypewriterCallback = null; // Clear the callback reference
              setTimeout(callback, 1000);
            }
          }
        }
        
        type();
      }
      
      // Shapey character functions
      function setShapeyMood(mood) {
        const shapey = document.getElementById('shapey-character');
        // Set image source based on mood
        if (mood === 'happy') {
          shapey.src = '/public/ShapeyHappy.png';
        } else if (mood === 'angry') {
          shapey.src = '/public/ShapeyAngry.png';
        } else if (mood === 'rolling') {
          shapey.src = '/public/ShapeyRolling.png';
        } else if (mood == 'unhappy') {
          shapey.src = '/public/ShapeyRolling.png';
        }
        
        // Preserve sliding-in class if it's present
        if (shapey.classList.contains('sliding-in')) {
          shapey.className = ''; // Clear all classes first
          shapey.classList.add(mood);
          shapey.classList.add('sliding-in');
        } else {
          shapey.className = mood; // mood can be 'happy', 'angry', or 'rolling'
        }
      }
      
      // Flag to track if speech bubble animation is in progress
      let speechAnimationInProgress = false;

      // Show speech bubble
      function showSpeechBubble(text, mood = 'happy', callback, showInsultButton = false, showInsultMeButton = false) {
        const speechText = document.getElementById('speech-text');
        const speechBubble = document.getElementById('speech-bubble');
        
        // Update flags for tracking insult button and initial dialogue
        shouldShowInsultButton = showInsultButton;
        shouldShowInsultMeButton = showInsultMeButton;
        
        // Cancel any ongoing animations by removing classes
        speechBubble.classList.remove('animating');
        
        // Clear existing text completely
        speechText.innerHTML = '';
        
        // Calculate accurate dimensions for the speech bubble
        const textDimensions = calculateTextDimensions(text);
        
        // Apply dimensions to the speech bubble before animation starts
        speechBubble.style.width = textDimensions.width;
        speechBubble.style.minHeight = textDimensions.height;
        
        // If the bubble is hidden, we need to show and animate it
        const wasHidden = speechBubble.classList.contains('hidden');
        
        // Remove hidden class and add animating class
        speechBubble.classList.remove('hidden');
        
        // Only add animation if it was previously hidden
        if (wasHidden) {
          // Force reflow to ensure CSS changes are applied before animation
          void speechBubble.offsetWidth;
          speechBubble.classList.add('animating');
        }
        
        // Set character mood
        setShapeyMood(mood);
        
        // Mark animation as in progress
        speechAnimationInProgress = true;
        
        const startTypewriter = () => {
          // Mark animation as complete
          speechAnimationInProgress = false;
          
          // Start the typewriter effect
          typeWriter(speechText, text, 30, () => {
            // Show insult button if requested
            if (showInsultButton) {
              const insultButton = document.getElementById('fancy-insult-button');
              insultButton.classList.remove('hidden');
              insultButton.classList.add('show');
            }
            
            // Show insult me button only if explicitly requested
            if (showInsultMeButton) {
              const insultMeButton = document.getElementById('insult-me-button');
              insultMeButton.classList.remove('hidden');
              insultMeButton.classList.add('show');
              insultMeButtonShown = true;
            }
            
            if (callback) {
              callback();
            }
          });
        };
        
        if (wasHidden) {
          // If bubble was hidden, wait for animation to complete
          speechBubble.addEventListener('animationend', function handleAnimEnd() {
            speechBubble.removeEventListener('animationend', handleAnimEnd);
            speechBubble.classList.remove('animating');
            startTypewriter();
          }, {once: true});
          
          // Safety timeout in case animation event doesn't fire
          setTimeout(() => {
            if (speechAnimationInProgress) {
              speechBubble.classList.remove('animating');
              startTypewriter();
            }
          }, 600);
        } else {
          // If already visible, start typewriter immediately
          startTypewriter();
        }
      }
      
      // Hide speech bubble with animation
      function hideSpeechBubble() {
        const speechBubble = document.getElementById('speech-bubble');
        const speechText = document.getElementById('speech-text');
        
        // Cancel any ongoing typewriter animations
        if (currentTypewriterTimer) {
          clearTimeout(currentTypewriterTimer);
          currentTypewriterTimer = null;
        }
        
        // Clear the text immediately
        speechText.innerHTML = '';
        
        // Hide the bubble
        speechBubble.classList.add('hidden');
      }
      
      // Function to slide Shapey in from off-screen
      function slideShapeyIn(callback) {
        const shapey = document.getElementById('shapey-character');
        shapey.classList.add('offscreen'); // Start offscreen
        
        // Force reflow to ensure the offscreen class is applied
        void shapey.offsetWidth;
        
        // Start slide-in animation
        shapey.classList.add('sliding-in');
        shapey.classList.remove('offscreen');
        
        // Call callback when animation ends
        shapey.addEventListener('animationend', function(e) {
          if (e.animationName === 'slide-in') {
            shapey.classList.remove('sliding-in');
            // Start bobbing animation after slide-in completes
            if (callback) callback();
          }
        }, {once: true});
      }
      
      // Example usage - show greeting when page loads
      // Create animated background shapes
      function createBackgroundShapes() {
        const shapesContainer = document.getElementById('shapes-background');
        const shapeTypes = ['triangle', 'square', 'pentagon', 'hexagon', 'circle'];
        const colors = ['rgba(255,82,82,0.08)', 'rgba(123,31,162,0.08)', 'rgba(33,150,243,0.08)', 
                        'rgba(255,193,7,0.08)', 'rgba(76,175,80,0.08)'];
        
        // Clear any existing shapes
        shapesContainer.innerHTML = '';
        
        // Create 20 random shapes
        for (let i = 0; i < 20; i++) {
          const shape = document.createElement('div');
          const shapeType = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
          const color = colors[Math.floor(Math.random() * colors.length)];
          
          // Random size between 30px and 100px
          const size = Math.floor(Math.random() * 70) + 30;
          
          // Random position
          const left = Math.floor(Math.random() * 100);
          const top = Math.floor(Math.random() * 100);
          
          // Random animation duration between 15s and 40s
          const duration = Math.floor(Math.random() * 25) + 15;
          
          // Random animation delay
          const delay = Math.floor(Math.random() * 10);
          
          // Apply styles
          shape.classList.add('floating-shape', shapeType);
          shape.style.width = `${size}px`;
          shape.style.height = `${size}px`;
          shape.style.left = `${left}%`;
          shape.style.top = `${top}%`;
          shape.style.backgroundColor = color;
          shape.style.animationDuration = `${duration}s`;
          shape.style.animationDelay = `-${delay}s`;
          
          // Add to container
          shapesContainer.appendChild(shape);
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        // Create background shapes
        createBackgroundShapes();
        
        // Start with Shapey off-screen
        const shapey = document.getElementById('shapey-character');
        shapey.classList.add('offscreen');
        
        // Ensure speech bubble is hidden initially
        const speechBubble = document.getElementById('speech-bubble');
        speechBubble.classList.add('hidden');
        
        // Ensure insult button is hidden initially
        const fancyInsultButton = document.getElementById('fancy-insult-button');
        fancyInsultButton.classList.add('hidden');
        
        // Add click event listeners for skipping dialogue
        shapey.addEventListener('click', () => {
          const speechBubble = document.getElementById('speech-bubble');
          
          // Make speech bubble jump when Shapey is clicked
          if (!speechBubble.classList.contains('hidden')) {
            // Add jumping class to speech bubble
            speechBubble.classList.add('jumping');
            
            // Remove jumping class when animation completes
            speechBubble.addEventListener('animationend', function onAnimEnd(e) {
              if (e.animationName === 'bubble-jump') {
                speechBubble.classList.remove('jumping');
                speechBubble.removeEventListener('animationend', onAnimEnd);
              }
            });
          }
          
          if (skipTypewriter()) {
            // Add pulse animation to provide visual feedback
            shapey.classList.add('pulse');
            // Remove the class after animation completes
            setTimeout(() => {
              shapey.classList.remove('pulse');
            }, 300);
          }
        });
        
        speechBubble.addEventListener('click', () => {
          if (skipTypewriter()) {
            // Add pulse animation to provide visual feedback
            speechBubble.classList.add('pulse');
            // Remove the class after animation completes
            setTimeout(() => {
              speechBubble.classList.remove('pulse');
            }, 300);
            
            // Also trigger the jumping animation
            speechBubble.classList.add('jumping');
            
            // Remove jumping class when animation completes
            speechBubble.addEventListener('animationend', function onAnimEnd(e) {
              if (e.animationName === 'bubble-jump') {
                speechBubble.classList.remove('jumping');
                speechBubble.removeEventListener('animationend', onAnimEnd);
              }
            });
          }
        });
        //!Shapeydelay
        setTimeout(() => {
          // 5-second delay before Shapey slides onto the screen
          // First slide Shapey in
          slideShapeyIn(() => {
            // Only show speech bubble after Shapey has slid in
            isInitialDialogue = true; // Mark this as the initial dialogue
            showSpeechBubble(
              "Hey there! I'm Shapey, and it looks like YOU'RE trying to play my game. It's pretty hard, so I wouldn't count on getting very far.\n\nActually, it's powered by Angle Intelligence, my own personal creation.\n\nEr, I mean, it was trained on data that basically belongs to me, anyways....\n\nWhat does it do? I have a feeling that you'll find out soon, if you're anything like most of the players who pass through these parts.", 
              'happy', 
              () => {
                isInitialDialogue = false; // Reset after dialogue completes
                initialDialogueCompleted = true; // Mark that initial dialogue has completed
              }, 
              true, // Show the insult button after dialogue completes
              false // Don't show the insult me button after initial dialogue
            );
          });
        }, 10000); // 5-second delay
        
        // Initialize variables for storing AI session
        let aiSessionId = null;
        let clientId = null;
        
        // Initialize AI session when page loads
        function initializeAISession() {
          fetch('/init-session')
            .then(response => {
              if (!response.ok) {
                throw new Error(`Failed to initialize AI session: ${response.status}`);
              }
              return response.json();
            })
            .then(data => {
              aiSessionId = data.sessionId;
              clientId = data.clientId;
              console.log('AI session initialized with ID:', aiSessionId);
            })
            .catch(error => {
              console.error('Error initializing AI session:', error);
            });
        }
        
        // Call init session when page loads
        initializeAISession();
        
        // Function to show animated loading dots
        function showLoadingDots() {
          const speechText = document.getElementById('speech-text');
          const loadingDots = document.getElementById('loading-dots');
          
          // Cancel any ongoing typewriter animations
          if (currentTypewriterTimer) {
            clearTimeout(currentTypewriterTimer);
            currentTypewriterTimer = null;
          }
          
          // Reset typewriter state
          currentTypewriterElement = null;
          currentTypewriterText = '';
          currentTypewriterCallback = null;
          isTypewriterActive = false;
          
          // Clear speech text and show loading dots
          speechText.innerHTML = '';
          loadingDots.classList.remove('hidden');
        }
        
        // Function to hide loading dots
        function hideLoadingDots() {
          const loadingDots = document.getElementById('loading-dots');
          loadingDots.classList.add('hidden');
        }
        
        // Function to fetch and display an insult
        function fetchInsult() {
          // First check if we need to cancel any ongoing typewriter animation
          if (isTypewriterActive) {
            // Stop any ongoing typewriter animation
            if (currentTypewriterTimer) {
              clearTimeout(currentTypewriterTimer);
              currentTypewriterTimer = null;
            }
            
            // Reset the typewriter state
            isTypewriterActive = false;
            currentTypewriterCallback = null;
            
            // If there's an element being used for typewriter, clear it
            if (currentTypewriterElement) {
              currentTypewriterElement.innerHTML = '';
              currentTypewriterElement = null;
            }
            
            currentTypewriterText = '';
          }
          
          if (!aiSessionId) {
            showSpeechBubble("Sorry, I'm not ready yet. Try again in a moment.", 'angry');
            // Retry initializing session
            initializeAISession();
            return;
          }
          
          // Show loading state with Shapey rolling and animated dots
          setShapeyMood('rolling');
          
          // Show speech bubble with empty text first
          const speechBubble = document.getElementById('speech-bubble');
          speechBubble.classList.remove('hidden');
          
          // Display the animated dots
          showLoadingDots();
          
          // Fetch the insult as text, not JSON
          fetch(`/insult?sessionId=${aiSessionId}&clientId=${clientId}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`Failed to fetch insult: ${response.status} ${response.statusText}`);
              }
              // Return as text since endpoint returns plain text
              return response.text();
            })
            .then(insultText => {
              // Hide the loading dots
              hideLoadingDots();
              
              if (insultText && insultText.trim()) {
                // Show the insult text with rolling mood briefly
                showSpeechBubble(insultText, 'rolling');
                
                // After a moment, change to angry mood
                setTimeout(() => {
                  setShapeyMood('angry');
                }, 1000);
              } else {
                throw new Error('Empty insult response received');
              }
            })
            .catch(error => {
              // Hide the loading dots
              hideLoadingDots();
              
              console.error('Error fetching insult:', error);
              let errorMessage = "I seem to be having trouble coming up with a good insult right now. Try again later.";
              
              // More specific error messages based on the error type
              if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                errorMessage = "Network error! Are you still connected to the internet? Try again when you're back online.";
              } else if (error.message.includes('404')) {
                errorMessage = "Hmm, it looks like the insult generator isn't available right now. The developers might be updating it.";
              }
              
              showSpeechBubble(errorMessage, 'angry');
              setShapeyMood('angry');
            });
        }
        
        // Track how many times the insult button is clicked
        let insultShapeyClickCount = 0;
      
        // Connect to fancy insult button
        fancyInsultButton.addEventListener('click', () => {
          // Track insult button clicks for dialogue purposes
          insultShapeyClickCount++;
        
          if (insultShapeyClickCount === 1) {
            // First click - happy and friendly but cautionary
            showSpeechBubble("Hey now, that's not very nice! I'm just trying to help you enjoy the game. Let's keep things friendly, okay?", 'happy');
          } else if (insultShapeyClickCount === 2) {
            // Second click - rolling face with a warning but no animation
            const shapey = document.getElementById('shapey-character');
            
            // Directly set the image source without adding the rolling class
            shapey.src = '/public/ShapeyRolling.png';
            
            // Preserve sliding-in class if it's present, but don't add rolling class
            if (shapey.classList.contains('sliding-in')) {
              shapey.className = 'sliding-in';
            } else {
              shapey.className = '';  // Remove any existing classes
            }
            
            // Show the warning message
            showSpeechBubble("Stop insulting me. I'm not joking around.", 'unhappy');
          } else if (insultShapeyClickCount === 3 || insultShapeyClickCount >= 4) {
            if (insultShapeyClickCount === 3) {
              // Show special message on third click and show button after dialogue completes
              showSpeechBubble(
                "Okay, FINE! You really want to play the insult game? Let's see how YOU like it! I've unlocked a special button just for you.", 
                'angry',
                () => {
                  // Only show the "Insult Me" button after dialogue completes and if initial dialogue is done
                  if (initialDialogueCompleted && !insultMeButtonShown) {
                    const insultMeButton = document.getElementById('insult-me-button');
                    insultMeButton.classList.remove('hidden');
                    insultMeButton.classList.add('show');
                    insultMeButtonShown = true;
                  }
                }
              );
            } else {
              // Any additional clicks after the 3rd
              showSpeechBubble("Go ahead, use that other button. See what happens!", 'angry');
              
              // For fourth click or later, immediately show the insult me button if it's not already shown
              if (!insultMeButtonShown) {
                const insultMeButton = document.getElementById('insult-me-button');
                insultMeButton.classList.remove('hidden');
                insultMeButton.classList.add('show');
                insultMeButtonShown = true;
              }
            }
          }
        });
      
        // Connect to insult me button
        const insultMeButton = document.getElementById('insult-me-button');
        insultMeButton.addEventListener('click', fetchInsult);
      
        // The "Insult Me" button will only appear after 3 clicks on the "Insult Shapey" button
      });
    </script>
  </body>
</html>
